<!doctype html>
<html>
<head>
    <meta charset="utf-8">

    <title>Antoine Jardin's Blog</title>

<link href='http://fonts.googleapis.com/css?family=Arvo:400,700' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Anonymous+Pro:400,700' rel='stylesheet' type='text/css'>
<link rel="stylesheet" type="text/css" href="/style.css">
</head>


<body>

    <div class="nav">
    <ul>
        <li><a href="http://antoinejardin.github.io/site/">Home</a></li>
        <li><a href="#">Data</a></li>
        <li><a href="#">Code</a></li>
		<li><a href="#">Research</a></li>
		<li><a href="#">Teaching</a><li>
        <li><a href="#">Papers</a></li>
        <li><a href="#">Archives</a><li>
        <li><a href="http://antoinejardin.github.io/site/about.html">About Me</a></li>
    </ul>
	</div>

  	<div class="content">
  	
  	<h3>[R Studio] : Ordinal regression with cumulative link single and mixed models</h3>
 
<p>Loading Packages. Ordinal provides both clm and clmm functions and their extractors</p>

<pre>
library(ordinal)
library(dplyr)
library(tidyr)
library(ggplot2)
</pre>

<p>Loading the dataset and identifying it as "data" for further command simplification</p>

<pre>
roma_ok <- read.csv("~/roma_ok.csv")
View(roma_ok)
data <- roma_ok
</pre>

<p>
Fitting the first Cumulative Link Model with "age" and "ethno" as independant variables and country as a random effect variable
First we need to explicitely define "roma" as a factor variable :	
</p>

<pre>
data$roma <- as.factor(data$roma)
</pre>

<p>
We define a simple model first, with no random effect, using the clm function. 
Here country is defined as a factor independant variable among others
</p>

<pre>
fm1 <- clm(roma ~ gender + ethno + contact + relig + country, data = data, Hess = TRUE, link="probit")
summary(fm1)
</pre>

<p>
To go further, we use a mixed model (i.e. hierarchichal or multilevel)
The syntaxt sharply follows the popular precedent included in the lme4 package by Douglas Bates.
This syntaxt is organised around the formula structure, separating the dependant variable with the "~" operator.
Then the random component is included, here specifying random intercept for each country using the "(1|country)" operator.
</p>	

<pre>
fm2 <- clmm(roma ~ gender + ethno + contact + relig + (1 | country), data = data, Hess = TRUE, link="probit")
summary(fm2)
fixef(fm2)
ranef(fm2)
</pre>

<p>
"fixef" allows us to extract fixed effects, that is, effects that are common across countries.
"raned" allows us to extract random effects, that is, effects that are country specific.
Here we only get a random country intercept, as specified in the formula.
</p>
		
<pre>
fm2 <- clmm(roma ~ gender + ethno + contact + relig  + (1 + contact | country), data = data, weights = pond, Hess = TRUE, link="probit")
summary(fm2)
ranef(fm2)
</pre>

<p>
We respecified the model adding the contact variable among both the fixed part and the random part of the formula.
This gives us a general (fixed) contact effect, and a country specific (random) contact effect.
The combined contact effect is the fixed + random contact effect.
</p>
	
<pre>
coefs(fm2)
fit2 <- fitted(fm2)
coefs4 <- data.frame(coef(summary(fm2)))
coefs4$p.z <- 2 * ( 1 - pnorm(abs(coefs4$t.value)))
</pre>

<p>
Here we (1) display the model coefficients, (2) compute the fitted values according to the model, (3) extract the coefficients form the model, (4) compute the p-value for each coefficient that was just extracted.
</p>

<pre>
odds <- as.data.frame(exp(coef(fm2)))
odds
</pre>

<p>
Then we take the exponential of each coefficient to display the odds ratio.
</p>
	
<pre>
datafit <- cbind(data, fit2)
</pre>

<p>
Finally we merge back the fitted values with the original dataset.
Then we save the resulting datafile as both a .csv for ease of use with R and as .dta to reuse it with Stata.
</p>
	
<pre>
write.csv(datafit, "romafit.csv")
library(foreign)
write.dta(datafit, "romafit.dta")
savehistory("~/rh.Rhistory")
</pre>

<p>
We're done for now !
</p>

    	<h3>[Stata] Typologie et classification</h3>

    	<p> Un exemple de technique de classification</p>

    	<pre>
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==1997
predict x_97 y_97 z_97
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==1998
predict x_98 y_98 z_98
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==1999
predict x_99 y_99 z_99
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2000
predict x_00 y_00 z_00
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2001
predict x_01 y_01 z_01
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2002
predict x_02 y_02 z_02
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2003
predict x_03 y_03 z_03
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2004
predict x_04 y_04 z_04
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2005
predict x_05 y_05 z_05
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2006
predict x_06 y_06 z_06
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2007
predict x_07 y_07 z_07
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2008
predict x_08 y_08 z_08
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2009
predict x_09 y_09 z_09
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2010
predict x_10 y_10 z_10
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2011
predict x_11 y_11 z_11
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2012
predict x_12 y_12 z_12
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2013
predict x_13 y_13 z_13
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] if session==2014
predict x_14 y_14 z_14
factor p_cs2 p_cs3 p_cs4 p_cs5 p_cs6 [w=tot_inscrits] 
predict x y z 
</pre>


    	<p> On calcule ensuite les k clusters pour les p années étudiées selon les axes x, y et z issues des analyses factorielles</p>

<pre>
cluster kmeans x_97 y_97 z_97 if session==1997, k(6) measure(L2) start(segments) name(_cl97)
cluster kmeans x_98 y_98 z_98 if session==1998, k(6) measure(L2) start(segments) name(_cl98)
cluster kmeans x_99 y_99 z_99 if session==1999, k(6) measure(L2) start(segments) name(_cl99)
cluster kmeans x_00 y_00 z_00 if session==2000, k(6) measure(L2) start(segments) name(_cl00)
cluster kmeans x_01 y_01 z_01 if session==2001, k(6) measure(L2) start(segments) name(_cl01)
cluster kmeans x_02 y_02 z_02 if session==2002, k(6) measure(L2) start(segments) name(_cl02)
cluster kmeans x_03 y_03 z_03 if session==2003, k(6) measure(L2) start(segments) name(_cl03)
cluster kmeans x_04 y_04 z_04 if session==2004, k(6) measure(L2) start(segments) name(_cl04)
cluster kmeans x_05 y_05 z_05 if session==2005, k(6) measure(L2) start(segments) name(_cl05)
cluster kmeans x_06 y_06 z_06 if session==2006, k(6) measure(L2) start(segments) name(_cl06)
cluster kmeans x_07 y_07 z_07 if session==2007, k(6) measure(L2) start(segments) name(_cl07)
cluster kmeans x_08 y_08 z_08 if session==2008, k(6) measure(L2) start(segments) name(_cl08)
cluster kmeans x_09 y_09 z_09 if session==2009, k(6) measure(L2) start(segments) name(_cl09)
cluster kmeans x_10 y_10 z_10 if session==2010, k(6) measure(L2) start(segments) name(_cl10)
cluster kmeans x_11 y_11 z_11 if session==2011, k(6) measure(L2) start(segments) name(_cl11)
cluster kmeans x_12 y_12 z_12 if session==2012, k(6) measure(L2) start(segments) name(_cl12)
cluster kmeans x_13 y_13 z_13 if session==2013, k(6) measure(L2) start(segments) name(_cl13)
cluster kmeans x_14 y_14 z_14 if session==2014, k(6) measure(L2) start(segments) name(_cl14)
cluster kmeans x y z , k(6) measure(L2) start(segments) name(_cl)
</pre>

<pre>
sc y_14 x_14 if _cl14==1, mc(blue) || sc y_14 x_14 if _cl14==2, mc(ltblue) || sc y_14 x_14 if _cl14==3, mc(lime) || sc y_14 x_14 if _cl14==4, mc(pink) ||sc y_14 x_14 if _cl14==5, mc(red) || sc y_14 x_14 if _cl14==6, mc(black)  

sc y_97 x_97 if _cl97==1, mc(blue) || sc y_97 x_97 if _cl97==2, mc(ltblue) || sc y_97 x_97 if _cl97==3, mc(lime) || sc y_97 x_97 if _cl97==4, mc(pink) ||sc y_97 x_97 if _cl97==5, mc(red) || sc y_97 x_97 if _cl97==6, mc(black)  

sc y_06 x_06 if _cl06==1, mc(blue) || sc y_06 x_06 if _cl06==2, mc(ltblue) || sc y_06 x_06 if _cl06==3, mc(lime) || sc y_06 x_06 if _cl06==4, mc(pink) ||sc y_06 x_06 if _cl06==5, mc(red) || sc y_06 x_06 if _cl06==6, mc(black)  

sc y_14 x_14 if _cl14==1, mc(blue) || sc y_14 x_14 if _cl14==2, mc(ltblue) || sc y_14 x_14 if _cl14==3, mc(lime) || sc y_14 x_14 if _cl14==4, mc(pink) ||sc y_14 x_14 if _cl14==5, mc(red) || sc y_14 x_14 if _cl14==6, mc(black)  , by(cep2)

sc y_06 x_06 if _cl06==1, mc(blue) || sc y_06 x_06 if _cl06==2, mc(ltblue) || sc y_06 x_06 if _cl06==3, mc(lime) || sc y_06 x_06 if _cl06==4, mc(pink) ||sc y_06 x_06 if _cl06==5, mc(red) || sc y_06 x_06 if _cl06==6, mc(black)  , by(cep2)
</pre>

<pre>
sort session
bysort session : egen tot_cep = total(cep2)
twoway line tot_cep session
</pre>

<pre>
tab cep2 _cl97
tab cep2 _cl98
tab cep2 _cl99
tab cep2 _cl98
tab cep2 _cl00
tab cep2 _cl01
tab cep2 _cl02
tab cep2 _cl03
tab cep2 _cl04
tab cep2 _cl05
tab cep2 _cl06
tab cep2 _cl07
tab cep2 _cl08
tab cep2 _cl09
tab cep2 _cl10
tab cep2 _cl11
tab cep2 _cl12
tab cep2 _cl13
tab cep2 _cl14
</pre>

<pre>
tab cep2 _cl97 , row nof 
tab cep2 _cl98 , row nof
tab cep2 _cl99 , row nof
tab cep2 _cl98 , row nof
tab cep2 _cl00 , row nof
tab cep2 _cl01 , row nof
tab cep2 _cl02 , row nof
tab cep2 _cl03 , row nof
tab cep2 _cl04 , row nof
tab cep2 _cl05 , row nof
tab cep2 _cl06 , row nof
tab cep2 _cl07 , row nof
tab cep2 _cl08 , row nof
tab cep2 _cl09 , row nof
tab cep2 _cl10 , row nof
tab cep2 _cl11 , row nof
tab cep2 _cl12 , row nof
tab cep2 _cl13 , row nof
tab cep2 _cl14 , row nof
</pre>    	

    </div>

    <div class="footer">
    Made in HTML and CSS - Antoine Jardin - 2015
    <div>


</body>
</html>

